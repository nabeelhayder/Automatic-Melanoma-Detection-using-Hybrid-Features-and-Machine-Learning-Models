# -*- coding: utf-8 -*-
"""Melonoma.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KIuTkfHfa3ui7vz3KpO1SadzsuS4_jlM

##**LEISIONS**
"""

import cv2
import numpy as np
from skimage import io, color, filters, morphology
import os
import matplotlib.pyplot as plt
def process_image(image_path, save_path):
    """
    This function performs basic noise reduction, hair removal, hole filling,
    and gap filling on an image. Please note that this is for educational purposes
    only and should not be used for medical diagnosis. Always consult a qualified
    dermatologist for any skin concerns.
    """

    original_color_image = io.imread(image_path)
    red_channel = original_color_image[:, :, 0]
    green_channel = original_color_image[:, :, 1]
    blue_channel = original_color_image[:, :, 2]
    gray_image = color.rgb2gray(original_color_image)
    blurred_image = filters.median(gray_image, selem=morphology.disk(5))
    blurred_image = (blurred_image * 255).astype(np.uint8)
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    eroded_image = cv2.erode(blurred_image, kernel, iterations=2)

    threshold = 127
    _, segmented_image = cv2.threshold(eroded_image, threshold, 255, cv2.THRESH_BINARY)
    opening_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    opened_image = cv2.morphologyEx(segmented_image, cv2.MORPH_OPEN, opening_kernel)
    closing_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))
    closed_image = cv2.morphologyEx(opened_image, cv2.MORPH_CLOSE, closing_kernel)
    dilation_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    dilated_image = cv2.dilate(closed_image, dilation_kernel, iterations=2)
    gap_filling_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (20, 20))
    gap_filled_image = cv2.dilate(dilated_image, gap_filling_kernel, iterations=1)
    inverted_image = cv2.bitwise_not(gap_filled_image)
    mask = np.ones_like(inverted_image) * 255
    mask[:100, :] = 0  # Set top rows to black
    mask[-100:, :] = 0  # Set bottom rows to black
    mask[:, :100] = 0  # Set left columns to black
    mask[:, -100:] = 0  # Set right columns to black
    result_image = cv2.bitwise_and(inverted_image, inverted_image, mask=mask)
    io.imsave(save_path, result_image)

    plt.figure(figsize=(20, 4))
    plt.subplot(171), plt.imshow(original_color_image), plt.title('Original Color Image')
    plt.subplot(172), plt.imshow(blurred_image, cmap='gray'), plt.title('Image without Hairs')
    plt.subplot(173), plt.imshow(segmented_image, cmap='gray'), plt.title('Segmented Image')
    plt.subplot(174), plt.imshow(opened_image, cmap='gray'), plt.title('Opened Image')
    plt.subplot(175), plt.imshow(closed_image, cmap='gray'), plt.title('Closed Image')
    plt.subplot(176), plt.imshow(dilated_image, cmap='gray'), plt.title('Dilated Image')
    plt.subplot(177), plt.imshow(result_image, cmap='gray'), plt.title('Processed Image with Larger Black Corners')
    plt.show()
    plt.figure(figsize=(15, 5))
    plt.subplot(131), plt.hist(red_channel.flatten(), bins=256, color='red', alpha=0.7, rwidth=0.8)
    plt.title('Red Channel Histogram')
    plt.subplot(132), plt.hist(green_channel.flatten(), bins=256, color='green', alpha=0.7, rwidth=0.8)
    plt.title('Green Channel Histogram')
    plt.subplot(133), plt.hist(blue_channel.flatten(), bins=256, color='blue', alpha=0.7, rwidth=0.8)
    plt.title('Blue Channel Histogram')
    plt.show()


    return original_color_image, blurred_image, segmented_image, opened_image, closed_image, dilated_image, result_image

folder_path = r'C:\Users\PMYLS\Desktop\Data\colored'
output_folder = r'C:\Users\PMYLS\Desktop\Data\segmented'

os.makedirs(output_folder, exist_ok=True)
image_files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]
for image_file in image_files:
    image_path = os.path.join(folder_path, image_file)

    save_path = os.path.join(output_folder, f"segmented_{image_file}")

    original_color, without_hairs, segmented, opened, closed, dilated, result_image = process_image(image_path, save_path)

print("Image processing complete. Remember, this is not for medical diagnosis!")

pip install --upgrade scikit-learn

import os
from skimage import io, util, color
from skimage.transform import resize
from sklearn.metrics import accuracy_score, confusion_matrix
import numpy as np

def calculate_segmentation_accuracy(ground_truth, predicted, threshold=0.5):
    predicted_resized = resize(predicted, ground_truth.shape, anti_aliasing=True, mode='reflect')

    ground_truth_binary = util.img_as_ubyte(ground_truth > threshold)
    predicted_binary = util.img_as_ubyte(predicted_resized > threshold)

    ground_truth_flat = ground_truth_binary.ravel()
    predicted_flat = predicted_binary.ravel()

    accuracy = accuracy_score(ground_truth_flat, predicted_flat)
    return accuracy

def calculate_overall_accuracy(segmented_dir, m_segmented_dir):
    segmented_files = sorted(os.listdir(segmented_dir))
    m_segmented_files = sorted(os.listdir(m_segmented_dir))

    total_accuracy = 0.0
    num_pairs = min(len(segmented_files), len(m_segmented_files))

    for i in range(num_pairs):
        segmented_filename = segmented_files[i]
        m_segmented_filename = m_segmented_files[i]

        if segmented_filename.endswith('.bmp') and m_segmented_filename.endswith('.bmp'):
            segmented_path = os.path.join(segmented_dir, segmented_filename)
            m_segmented_path = os.path.join(m_segmented_dir, m_segmented_filename)

            # Load the images
            segmented_img = io.imread(segmented_path)
            m_segmented_img = io.imread(m_segmented_path)

            # Calculate accuracy for the pair
            accuracy = calculate_segmentation_accuracy(segmented_img, m_segmented_img)
            print(f"Accuracy for {segmented_filename}: {accuracy}")

            total_accuracy += accuracy

    overall_accuracy = total_accuracy / num_pairs if num_pairs > 0 else 0.0
    print(f"\nOverall Accuracy: {overall_accuracy}")

# Specify directories
segmented_dir = r'C:\Users\PMYLS\Desktop\Data\segmented'
m_segmented_dir = r'C:\Users\PMYLS\Desktop\Data\m_segmented'

# Calculate and print overall accuracy
calculate_overall_accuracy(segmented_dir, m_segmented_dir)

"""##**SEGMENTATION ACCURACY**"""

import os
from skimage import io, util, color
from skimage.transform import resize
from sklearn.metrics import confusion_matrix
import numpy as np

def calculate_segmentation_metrics(ground_truth, predicted, threshold=0.5):
    predicted_resized = resize(predicted, ground_truth.shape, anti_aliasing=True, mode='reflect')
    ground_truth_binary = util.img_as_ubyte(ground_truth > threshold)
    predicted_binary = util.img_as_ubyte(predicted_resized > threshold)
    ground_truth_flat = ground_truth_binary.ravel()
    predicted_flat = predicted_binary.ravel()
    cm = confusion_matrix(ground_truth_flat, predicted_flat)

    true_positive = cm[1, 1]
    false_negative = cm[1, 0]
    true_negative = cm[0, 0]
    false_positive = cm[0, 1]

    sensitivity = true_positive / max((true_positive + false_negative), 1)
    specificity = true_negative / (true_negative + false_positive)

    return cm, sensitivity, specificity

def calculate_overall_metrics(segmented_dir, m_segmented_dir):
    segmented_files = sorted(os.listdir(segmented_dir))
    m_segmented_files = sorted(os.listdir(m_segmented_dir))

    total_confusion_matrix = np.zeros((2, 2), dtype=int)
    total_sensitivity = 0.0
    total_specificity = 0.0
    num_pairs = min(len(segmented_files), len(m_segmented_files))

    for i in range(num_pairs):
        segmented_filename = segmented_files[i]
        m_segmented_filename = m_segmented_files[i]

        if segmented_filename.endswith('.bmp') and m_segmented_filename.endswith('.bmp'):
            segmented_path = os.path.join(segmented_dir, segmented_filename)
            m_segmented_path = os.path.join(m_segmented_dir, m_segmented_filename)


            segmented_img = io.imread(segmented_path)
            m_segmented_img = io.imread(m_segmented_path)
            cm, sensitivity, specificity = calculate_segmentation_metrics(segmented_img, m_segmented_img)
            total_confusion_matrix += cm
            total_sensitivity += sensitivity
            total_specificity += specificity
    overall_sensitivity = total_sensitivity / num_pairs if num_pairs > 0 else 0.0
    overall_specificity = total_specificity / num_pairs if num_pairs > 0 else 0.0

    print(f"\nOverall Metrics:")
    print(f"Overall Sensitivity: {overall_sensitivity}")
    print(f"Overall Specificity: {overall_specificity}")
    print(f"Overall Confusion Matrix:\n{total_confusion_matrix}")


segmented_dir = r'C:\Users\PMYLS\Desktop\Data\segmented'
m_segmented_dir = r'C:\Users\PMYLS\Desktop\Data\m_segmented'
calculate_overall_metrics(segmented_dir, m_segmented_dir)

"""##**FEATURE EXTRATION**"""

import os
import cv2
from skimage import feature
import numpy as np
import csv
from skimage.measure import shannon_entropy
def extract_features(image_path):
    colored_image = cv2.imread(image_path)
    gray_image = cv2.cvtColor(colored_image, cv2.COLOR_BGR2GRAY)

    # Feature extraction using Local Binary Pattern (LBP)
    radius = 1
    n_points = 8 * radius
    lbp_features = feature.local_binary_pattern(gray_image, n_points, radius, method="uniform")

    # HOG features
    orientations = 9
    pixels_per_cell = (8, 8)
    cells_per_block = (2, 2)
    hog_features = feature.hog(gray_image, orientations=orientations, pixels_per_cell=pixels_per_cell, cells_per_block=cells_per_block, block_norm='L2-Hys')

    # Color features
    color_mean = np.mean(colored_image, axis=(0, 1))
    color_std = np.std(colored_image, axis=(0, 1))

    # Texture Features (Entropy)
    entropy = shannon_entropy(gray_image)

    # Shape features
    contours, _ = cv2.findContours(gray_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contour = max(contours, key=cv2.contourArea)
    area = cv2.contourArea(contour)
    perimeter = cv2.arcLength(contour, True)
    compactness = (perimeter ** 2) / (4 * np.pi * area) if area > 0 else 0
    moments = cv2.moments(contour)
    eccentricity = np.sqrt((moments["m20"] - moments["m02"])**2 + 4 * moments["m11"]**2) / (moments["m20"] + moments["m02"])

    # Reshape the features to a 1D array
    flat_features = np.concatenate([lbp_features.flatten(), hog_features, color_mean, color_std, [entropy, compactness, eccentricity]])

    return flat_features, hog_features

# Folders for original colored images
colored_folder_path = r'C:\Users\PMYLS\Desktop\Data\colored'

# Create output folder for features
features_folder_path = r'C:\Users\PMYLS\Desktop\Data\extracted_features'
os.makedirs(features_folder_path, exist_ok=True)

# Create a CSV file to save image names and features
csv_file_path = os.path.join(features_folder_path, 'features.csv')

# Open the CSV file in write mode
with open(csv_file_path, 'w', newline='') as csvfile:
    # Create a CSV writer
    csv_writer = csv.writer(csvfile)

    # Write the header to the CSV file
    header = ['Image Name'] + [f'LBP Feature {i}' for i in range(1, 9)] + \
             [f'HOG Feature {i}' for i in range(1, 10)] + \
             ['Color Mean (R)', 'Color Mean (G)', 'Color Mean (B)',
              'Color Std (R)', 'Color Std (G)', 'Color Std (B)',
              'Entropy', 'Area', 'Perimeter', 'Compactness', 'Eccentricity']
    csv_writer.writerow(header)


    for filename_colored in os.listdir(colored_folder_path):
        if filename_colored.endswith(".bmp"):

            image_path = os.path.join(colored_folder_path, filename_colored)


            features, _ = extract_features(image_path)
            row_data = [filename_colored] + list(features)
            csv_writer.writerow(row_data)

print("Feature extraction complete.")

"""##**Automatic Melanoma Detection using Hybrid Features and Machine Learning Models**"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = r'C:\Users\PMYLS\Desktop\Data\extracted_features\features.csv'
df = pd.read_csv(file_path)
df_filled = df.fillna(df.mean())
selected_columns = ['LBP Feature 1', 'LBP Feature 2', 'LBP Feature 3', 'LBP Feature 4', 'LBP Feature 5',
                    'LBP Feature 6', 'LBP Feature 7', 'LBP Feature 8', 'HOG Feature 1', 'HOG Feature 2',
                    'HOG Feature 3', 'HOG Feature 4', 'HOG Feature 5', 'HOG Feature 6', 'HOG Feature 7',
                    'HOG Feature 8', 'HOG Feature 9', 'Color Mean (R)', 'Color Mean (G)', 'Color Mean (B)',
                    'Color Std (R)', 'Color Std (G)', 'Color Std (B)', 'Entropy', 'Area', 'Perimeter',
                    'Compactness', 'Eccentricity', 'Melanoma']

df_selected = df[selected_columns]
correlation_matrix = df_selected.corr()
plt.figure(figsize=(16, 12))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", fmt=".2f", linewidths=.5)
plt.title("Correlation Matrix Heatmap")
print(df_selected.head())
plt.show()

"""##**LOGISTIC REGRESSION**"""

from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, roc_curve, auc
import numpy as np

# Assuming 'Melanoma' is the target variable
X = df_selected.drop('Melanoma', axis=1)
y = df_selected['Melanoma']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize Logistic Regression model
logreg_model = LogisticRegression()

# K-fold cross-validation
kf = KFold(n_splits=5, shuffle=True, random_state=42)

# Cross-validation scores
cv_scores = cross_val_score(logreg_model, X_train, y_train, cv=kf, scoring='accuracy')

# Print the cross-validation scores
print("Cross-validation scores:", cv_scores)
print("Mean accuracy:", np.mean(cv_scores))

# Fit the model on the entire training set
logreg_model.fit(X_train, y_train)

# Predictions on the test set
y_pred = logreg_model.predict(X_test)

# Accuracy on the test set
test_accuracy = accuracy_score(y_test, y_pred)
print("Accuracy on the test set:", test_accuracy)

# Confusion Matrix
conf_matrix = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(conf_matrix)

# Plot Confusion Matrix
plt.figure(figsize=(5, 3))
sns.heatmap(conf_matrix, annot=True, cmap="Blues", fmt="d", linewidths=.5)
plt.title("Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

# ROC Curve
fpr, tpr, thresholds = roc_curve(y_test, logreg_model.predict_proba(X_test)[:,1])
roc_auc = auc(fpr, tpr)

# Plot ROC Curve
plt.figure(figsize=(5, 3))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (AUC = {:.2f})'.format(roc_auc))
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()

"""##**SVM**"""

from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline

X = df_selected.drop('Melanoma', axis=1)
y = df_selected['Melanoma']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
svm_model = make_pipeline(StandardScaler(), SVC(probability=True))
cv_scores_svm = cross_val_score(svm_model, X_train, y_train, cv=kf, scoring='accuracy')
print("Cross-validation scores for SVM:", cv_scores_svm)
print("Mean accuracy for SVM:", np.mean(cv_scores_svm))
svm_model.fit(X_train, y_train)
y_pred_svm = svm_model.predict(X_test)

test_accuracy_svm = accuracy_score(y_test, y_pred_svm)
print("Accuracy on the test set for SVM:", test_accuracy_svm)
conf_matrix_svm = confusion_matrix(y_test, y_pred_svm)
print("Confusion Matrix for SVM:")
print(conf_matrix_svm)
plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix_svm, annot=True, cmap="Blues", fmt="d", linewidths=.5)
plt.title("Confusion Matrix for SVM")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

# ROC Curve for SVM
fpr_svm, tpr_svm, thresholds_svm = roc_curve(y_test, svm_model.predict_proba(X_test)[:,1])
roc_auc_svm = auc(fpr_svm, tpr_svm)

# Plot ROC Curve for SVM
plt.figure(figsize=(6, 4))
plt.plot(fpr_svm, tpr_svm, color='darkorange', lw=2, label='ROC curve for SVM (AUC = {:.2f})'.format(roc_auc_svm))
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve for SVM')
plt.legend(loc="lower right")
plt.show()

"""##**KNN**"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report

X = df_selected.drop('Melanoma', axis=1)
y = df_selected['Melanoma']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
knn_model = KNeighborsClassifier(n_neighbors=5)

knn_model.fit(X_train, y_train)
y_pred_knn = knn_model.predict(X_test)
test_accuracy_knn = accuracy_score(y_test, y_pred_knn)
print("Accuracy on the test set for KNN:", test_accuracy_knn)
class_report_knn = classification_report(y_test, y_pred_knn)
print("Classification Report for KNN:")
print(class_report_knn)
conf_matrix_knn = confusion_matrix(y_test, y_pred_knn)
print("Confusion Matrix for KNN:")
print(conf_matrix_knn)

plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix_knn, annot=True, cmap="Blues", fmt="d", linewidths=.5)
plt.title("Confusion Matrix for KNN")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

"""##**Decision Tree**"""

from sklearn.tree import DecisionTreeClassifier, plot_tree
X = df_selected.drop('Melanoma', axis=1)
y = df_selected['Melanoma']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
dt_model = DecisionTreeClassifier(random_state=42)

dt_model.fit(X_train, y_train)
y_pred_dt = dt_model.predict(X_test)
test_accuracy_dt = accuracy_score(y_test, y_pred_dt)
print("Accuracy on the test set for Decision Tree:", test_accuracy_dt)

class_report_dt = classification_report(y_test, y_pred_dt)
print("Classification Report for Decision Tree:")
print(class_report_dt)

conf_matrix_dt = confusion_matrix(y_test, y_pred_dt)
print("Confusion Matrix for Decision Tree:")
print(conf_matrix_dt)

plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix_dt, annot=True, cmap="Blues", fmt="d", linewidths=.5)
plt.title("Confusion Matrix for Decision Tree")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

plt.figure(figsize=(20, 10))
plot_tree(dt_model, feature_names=df_selected.columns[:-1], class_names=['Non-Melanoma', 'Melanoma'], filled=True, rounded=True)
plt.title("Decision Tree Plot")
plt.show()